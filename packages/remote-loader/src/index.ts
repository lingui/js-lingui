import { createBrowserCompiledCatalog } from "./browserCompiler"
import PARSERS from "./minimalParser"

type RemoteLoaderOpts<T> = {
  format?: "minimal"
  fallbackMessages?: string | Record<string, any> | T
  messages: string | Record<string, any> | T
}

export function remoteLoader<T>({
  format = "minimal",
  fallbackMessages,
  messages,
}: RemoteLoaderOpts<T>) {
  let parsedMessages: any
  let parsedFallbackMessages: any

  if (format) {
    const formatter = PARSERS[format]
    if (fallbackMessages) {
      // we do this because, people could just import the fallback and import the ./en/messages.js
      // generated by lingui and the use case of format .po but fallback as .json module could be perfectly valid
      parsedFallbackMessages =
        typeof fallbackMessages === "object"
          ? PARSERS.minimal(fallbackMessages)
          : formatter(fallbackMessages)
    }

    parsedMessages = formatter(messages)
  } else {
    throw new Error(`
        *format* value in the Lingui configuration is required to make this loader 100% functional
        Read more about this here: https://lingui.dev/ref/conf#format
      `)
  }

  const mapTranslationsToInterpolatedString = Object.fromEntries(
    // if there's fallback and translation is empty, return the fallback
    Object.keys(parsedMessages).map((key) => [
      key,
      parsedMessages[key].translation === "" &&
      parsedFallbackMessages?.[key]?.translation
        ? parsedFallbackMessages[key].translation
        : parsedMessages[key].translation,
    ])
  )

  return createBrowserCompiledCatalog(mapTranslationsToInterpolatedString)
}
